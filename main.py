# print(7, 8, 9)

# n = 5
# print(n)

# n = 'fdsf'
# print(type(n))

# n = 131
#print(type(n))

# n = 'fdnkj\'sf'
# print(n)

# a = 5
# b = 1.32
# c = 'fsdf'

# print(a, b, c)


# a = 5
# b = 1.32
# c = 'fsdf'

# #print(f"{a} - {b} - {c}")   # или по другому нижее показиваем
# print("{} - {} - {}".format(a,b,c))

# print("введите первый строку")


# a = input()
# print(a)

# c = 2.12
# print(c)

# n = int(c)
# print(n)
# d = 5
# d = bool(d)
# print(d)
# print(type(d))



# n = int(input('введите первый число: '))

# m = int(input('введите второй число: '))

# print(n, ' + ', m, '=', n + m)

# a = 2.56854
# b = 6.345111
# print(a*b)

# a = 2.56854
# b = 6.345111
# print(round(a*b, 3)) # чтобы округлит остаток ползуется фу-я (round)

# a = 2.56854
# b = 6.345111
# print(round(a*b, 5))

# a = 1 > 4
# print(a)

# b = 5 > 2 and 3>1
# print(b)

# a = 1 < 5 < 3 > 2
# print(a)

# i = 0
# while (i < 5):
#     # if i == 3:
#     #     break
#      i = i + 1
# else:
#     print('Ну Да')
#     print('Да хватит')
# print(i)

# a = 'qwerty'
# print(a[0]) # это значит выводи букву стояший 0 индексе в строке

# a = 'qwerty'
# for i in a:
#     print(i)

text = 'да поехали от сюда пока не позно'
# print(len(text))
# text = 'да поехали от сюда пока не позно'
# print(text[:]) # показивает вес текст
print(text[:3]) # показивает до 3 значени массива не включит третий индекс значение
# print(text[15:])  # показивает с 15 индекса до конца
# print(text[7:-13]) # это все об срезе примеры


# По данному целому неотрицательному n вычислите
# значение n!. N! = 1 * 2 * 3 * … * N (произведение всех
# чисел от 1 до N) 0! = 1 Решить задачу используя цикл
# while

# n = int(input())
# i = 1
# result = 1
# while i <= n:
#     result *= i
#     i += 1
# print(result)


# Дано натуральное число A > 1. Определите, каким по
# счету числом Фибоначчи оно является, то есть
# выведите такое число n, что φ(n)=A. Если А не
# является числом Фибоначчи, выведите число -1.  Число фибоначчи это типа 0 1 1 2 3 5 8 13,,, передедуший 2 число следуший сло жение 0+1=1 1+1 =2

# n = int(input())
# n0 = 0
# n1 = 0
# n2 = 1
# i = 2
# while n0 < n:
#     n0 = n1 + n2
#     n1 = n2
#     n2 = n0
#     i += 1
#     if n0 > n:
#         i = -1
# print(i)

# Уставшие от необычно теплой зимы, жители решили узнать,
# действительно ли это самая длинная оттепель за всю историю
# наблюдений за погодой. Они обратились к синоптикам, а те, в
# свою очередь, занялись исследованиями статистики за
# прошлые годы. Их интересует, сколько дней длилась самая
# длинная оттепель. Оттепелью они называют период, в
# который среднесуточная температура ежедневно превышала
# 0 градусов Цельсия. Напишите программу, помогающую
# синоптикам в работе.
# Пользователь вводит число N – общее количество
# рассматриваемых дней (1 ≤ N ≤ 100). В следующих строках
# располагается N целых чисел.
# Каждое число – среднесуточная температура в
# соответствующий день. Температуры – целые числа и лежат в
# диапазоне от –50 до 50

# n = int(input())   #количество дней
# k = 0 # оттопел дней
# max = 0 # tempratura

# for i in range(n):
#     x = int(input())
#     if x > 0:
#         k += 1
#     else:
#         if max < k:
#             max = k
#         k = 0
# print(max)           


#  Иван Васильевич пришел на рынок и решил
# купить два арбуза: один для себя, а другой для тещи.
# Понятно, что для себя нужно выбрать арбуз
# потяжелей, а для тещи полегче. Но вот незадача:
# арбузов слишком много и он не знает как же выбрать
# самый легкий и самый тяжелый арбуз? Помогите ему!
# Пользователь вводит одно число N – количество
# арбузов. Вторая строка содержит N чисел,
# записанных на новой строчке каждое. Здесь каждое
# число – это масса соответствующего арбуза     

# n = int(input())
# max = -1
# min = 3001

# for i in range(n):
#     x = int(input())
#     if x > max:
#         max = x
#     if x < min:        
#         min = x
        
        
# print(max, min)


# Список
# list_1 = []
# list_1 = list()
# print(list_1)
# list_1 = []
# list_1 = [1, 2, 3]
# print(list_1)

# list_1 = []
# list_1 = [1, 2, 3]
# print(*list_1)     # для убрат [] нужно ставит *

# for i in list_1:
#     print(i)
#     print(len(list_1)) # это для определение длина спискоа
#     print(list_1[2]) # для определеня значение указанный номера элемента

# list = [2, 7]
# print(list)
# list.append(6)       #.append добавление элемента в спике следуюшим
# print(list)

# list = []
# print(list)

# for i in range(6):
#     list.append(i)
#     print(list) # этот код начиная с пустый [] до сначала 0 потом 0, 1 потом ... 0,1,2,3,4,5 шесть штук элементов


# функциия удаление это .pop  примери

# list = [2, 36, -16, 0]
# print(list.pop()) # если один раз удаляет последный элемент в списке это 0
# print(list)
# print(list.pop())
# print(list)
# print(list.pop())
# print(list)

#Удаление конкретного элемента

# list = [2, 36, -16, 0]
# print(list.pop(2)) # функсия удалить конкретного элементо здес второй индек (0 1 2 3)
# print(list)

# для добовление конкретный элемент конкретного позиции тогда исползуется

# list = [2, 55, -18, 1, -26]
# print(list.insert(2,31))  # этот функция добавит 31 месте 2 ого индекса
# print(list)

# Кортеж и свойства ползуется ( ) пара чисел или строк
# t = ()
# print(type(t))

# t = (1)
# print(type(t))

# t = (1, 2,)
# print(type(t))

# v = [1, 2, 3]
# print(v)
# print(type(v))

# v = tuple(v)
# print(v)
# print(type(v))

# d = {}
# d = dict()

# d['q'] = 'qwerty'
# print(d)

# d['w'] = 'werty'
# print(d)

# print(d['w'])


# Множнство {} using
 
# colors = {'red', 'white', 'green'}
# print(colors)

# colors.add('red')
# print(colors)

# colors.add('yellow')
# print(colors)
# colors.discard('white') # удаляет выше указанный цвет
# print(colors) 
# colors.clear()
# print(colors)

# a = {1, 2, 6, 3, 11}
# b = {3, 7, 9 , 2, 0}

# c = a.copy()    #копирования а как с будеть
# print(c)
# n = a.union(b) # обединение двухух значение как один
# print(n)

# l = a.intersection(b) # пересечение
# print(l)
# s = a.difference(b) # найдет не стиковку разнмцу здес приоритете cтроке'a' если начинат b.difference(a)
# print(s)

# # Замароженный множества

# f = {2, 0, 6}
# r = frozenset(f)
# print(r)

# создать список состаяший четныйх чисел диапазоне от 1 до 100 сначала обычный вариант потом list comprehinsion 

# list = []
# for i in range(1, 101):
#     list.append(i)
# print(list)
    
# list = [i for i in range(1, 101)]    # это от 1 до 100 подряд
# print(list)
  
# list = [i for i in range(1, 101) if i % 2 ==0]    # это от 1 до 100 подряд но тоько четный чисел
# print(list)  

# list = [(i, i) for i in range(1, 101) if i % 2 ==0]    # это от 1 до 100 подряд но тоько четный чисел еще это кортеж состоявшый из пара чисел
# print(list)  

# list = [i * 2 for i in range(1, 101) if i % 2 ==0]    # это от 1 до 100 подряд но тоько четный можно умножит делить и так далее
# print(list)

# Напишите программу, которая принимает на вход
# строку, и отслеживает, сколько раз каждый символ
# уже встречался. Количество повторов добавляется к
# символам с помощью постфикса формата _n.
# Input: a a a b c a a d c d d
# Output: a a_1 a_2 b c a_3 a_4 d c_1 d_1 d_2
# Для решения данной задачи используйте функцию
# .split()


# input_string = "a a a b c a a d c d d"  # Пример ввода
# words = input_string.split()  # Разбиваем строку на слова
# char_count = {}  # Создаем словарь для отслеживания количества встреч каждого символа

# # Проходимся по каждому слову
# for word in words:
#     # Проходимся по каждому символу в слове
#     for char in word:
#         # Обновляем счетчик для текущего символа
#         char_count[char] = char_count.get(char, 0) + 1

# output_string = ""  # Создаем пустую строку для вывода результата

# # Проходимся по каждому слову
# for word in words:
#     # Проходимся по каждому символу в слове
#     for char in word:
#         # Формируем строку вывода, добавляя символ и его количество повторений
#         output_string += char + "_" + str(char_count[char]) + " "
#         # Уменьшаем счетчик повторений для текущего символа
#         char_count[char] -= 1

# # Выводим результат
# print("Output:", output_string.strip())

# следуюший вариант решений
# stroka = input().split()      # функция split() переобразует строку в массив
# result = {}          # kolichstvo povtaryayushiy elementa


# for i in stroka:
#     if i in result:
#         print(f'{i}_{result[i]}', end = ' ')
#     else:
#         print(i, end = ' ')
#     result[i] = result.get(i, 0) + 1        


# # Пользователь вводит текст(строка). Словом считается # последовательность непробельных символов идущих
# # подряд, слова разделены одним или большим числом# пробелов. Определите, сколько различных слов
# # содержится в этом тексте.
# # Input: She sells sea shells on the sea shore The shells # that she sells are sea shells I'm sure.So if she sells sea
# # shells on the sea shore I'm sure that the shells are sea # shore shells
# # Output: 13

# input_text = "She sells sea shells on the sea shore The shells that she sells are sea shells I'm sure.So if she sells sea shells on the sea shore I'm sure that the shells are sea shore shells"

# # Разбиваем текст на слова с помощью пробелов в качестве разделителя
# words = input_text.split()

# # Создаем множество для хранения уникальных слов
# unique_words = set(words)

# # Выводим количество уникальных слов
# print(len(unique_words))


# n = int(input())
# Другой вариант


# stroka = input().split()
# words = set()
# for i in stroka:
#     words.add(i.lower())
# print(len(words))


# Ваня и Петя поспорили, кто быстрее решит
# следующую задачу: “Задана последовательность
# неотрицательных целых чисел. Требуется определить
# значение наибольшего элемента
# последовательности, которая завершается первымф
# встретившимся нулем (число 0 не входит в
# последовательность)”. Однако 2 друга оказались не
# такими смышлеными. Никто из ребят не смог до
# конца сделать это задание. Они решили так: у кого
# будет меньше ошибок в коде, тот и выиграл спор. За
# помощью товарищи обратились к Вам, студентам.


# находим сумму ot 1 do n элементов с помошю функции в пайтон

# def sum_numbers(n):
#     summa = 0
#     for i in range(1, n+1):
#         summa +=i
#     print(summa)
# sum_numbers(8)


#другой вариант

# def sum_numbers(n):
#     summa = 0
#     for i in range(1, n+1):  # почему n+1 потомучто функция не берет последный элемент а нам нужен n элемент
#         summa +=i
#     print(summa)
    
# n = int(input())
# sum_numbers(n)


# следуший задача преставим нам дано несколко буквы нужен чтобы оно отразилась как един

# def sum_str(*args):
#     result = ''
#     for i in args:
#         result += i
#     return result
# print(sum_str('a', 'b', 'c', 'd'))    



# Последовательностью Фибоначчи называется
# последовательность чисел a0
# , a1
# , ..., an
# , ..., где
# a0
#  = 0, a1
#  = 1, ak
#  = ak-1 + ak-2 (k > 1).
# Требуется найти N-е число Фибоначчи       

# def f(n):
#     if n == 0 or n == 1:
#         return 1
#     return f(n - 1) + f(n - 2)
# n = int(input())

# print(f(n))

# Хакер Василий получил доступ к классному журналу и
# хочет заменить все свои минимальные оценки на
# максимальные. Напишите программу, которая
# заменяет оценки Василия, но наоборот: все
# максимальные – на минимальные


# n = int(input())

# list1 = list()
# for i in range(n):
#     x = int(input())
#     list1.append(x)
    
# max_n = max(list1)
# min_n = min(list1)

# for i in range(len(list1)):
#     if list1[i] == max_n:
#         list1[i] = min_n
# print(list1)

# Напишите функцию, которая принимает одно число и
# проверяет, является ли оно простым
# Напоминание: Простое число - это число, которое
# имеет 2 делителя: 1 и n(само число)

# def simple_numbers(n):
#     flag = True
#     i = 2
#     while i < n and flag:
#         if n % i == 0:
#             flag = False
            
#         i += 1
        
#     if flag: 
#         return 'Yes'   
#     else:
#         return 'No'
# n = int(input())
# print(simple_numbers(n))

# Дано натуральное число N и
# последовательность из N элементов.
# Требуется вывести эту последовательность в
# обратном порядке.
# Примечание. В программе запрещается
# объявлять массивы и использовать циклы
# (даже для ввода и вывода).

# def f(n):
#     if n == 0:
#         return ''
#     k = int(input())
#     return f(n - 1) + f'{k}'

# n = int(input())
# print(f(n))

# Даны два массива чисел. Требуется вывести те элементы
# первого массива (в том порядке, в каком они идут в первом
# массиве), которых нет во втором массиве. Пользователь вводит
# число N - количество элементов в первом массиве, затем N
# чисел - элементы массива. Затем число M - количество
# элементов во втором массиве. Затем элементы второго массива

# n = int(input())
# list1 = list()
# for i in range(n):
#     x = int(input())
#     list1.append(x)
    
# m = int(input())
# list2 = list()
# for i in range(m):
#     x = int(input())
#     list2.append(x)

# count = 0
# for i in range(n):
#     for j in range(m):
#         if list1[i] == list2[j]:
#             count += 1
#     if count == 0:
#             print(list1[i])
#     count = 0


# Дан массив, состоящий из целых чисел. Напишите
# программу, которая в данном массиве определит
# количество элементов, у которых два соседних и, при
# этом, оба соседних элемента меньше данного. Сначала
# вводится число N — количество элементов в массиве
# Далее записаны N чисел — элементы массива. Массив
# состоит из целых чисел.


# n = int(input())
# list1 = list()
# for i in range(n):
#     x = int(input())
#     list1.append(x)
# count = 0
# for i in range(n):
#     if list1[i] < list1[(i - 1)]:
#         count += 1
# print(count) 

# другой версия

# n = int(input())
# list1 = list()
# for i in range(n):
#     x = int(input())
#     list1.append(x)
# count = 0
# for i in range(1, n-1):
#     if list1[i-1] < list1[i] > list1[i+1]:
#         count += 1
# print(count) 

# Дан список чисел. Посчитайте, сколько в нем пар
# элементов, равных друг другу. Считается, что любые
# два элемента, равные друг другу образуют одну пару,
# которую необходимо посчитать. Вводится список
# чисел. Все числа списка находятся на разных      

# list1 = [1, 2, 3, 2, 3]
# count = 0

# for i in range(len(list1)):
#     for j in range(i+1, len(list1)):
#         if i != j and list1[i] == list1[j]:
#             count += 1
# print(count)


# Два различных натуральных числа n и m называются
# дружественными, если сумма делителей числа n
# (включая 1, но исключая само n) равна числу m и
# наоборот. Например, 220 и 284 – дружественные числа.
# По данному числу k выведите все пары дружественных
# чисел, каждое из которых не превосходит k. Программа
# получает на вход одно натуральное число k, не
# превосходящее 105
# . Программа должна вывести все
# пары дружественных чисел, каждое из которых не
# превосходит k. Пары необходимо выводить по одной в
# строке, разделяя пробелами. Каждая пара должна быть
# выведена только один раз (перестановка чисел новую
# пару не дает).

# k = int(input())
# list1 = list()

# for i in range(k):
#     summa = 0
#     for j in range(1, i // 2 +1):
#         if i % j == 0:
#             summa += j
#     list1.append(tuple([i, summa]))   
# for i in range(len(list1)):
#     for j in range(i, len(list1)):
#         if i != j and list1[i][0] == list1[j][1] and list1[i][1] == list1[j][0]:
#             print(list1[i])
        
# Создать телефонный справочник с
# возможностью импорта и экспорта данных в
# формате .txt. Фамилия, имя, отчество, номер
# телефона - данные, которые должны находиться
# в файле.
# 1. Программа должна выводить данные
# 2. Программа должна сохранять данные в
# текстовом файле
# 3. Пользователь может ввести одну из
# характеристик для поиска определенной
# записи(Например имя или фамилию
# человека)
# 4. Использование функций. Ваша программа
# не должна быть линейной
            
    
    
        
        

    
    
             
        
            
    





    
   
    
