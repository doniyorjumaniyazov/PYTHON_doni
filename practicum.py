#За день машина проезжает n километров. Сколько дней нужно, чтобы проехать маршрут длиной m
#километров? При решении этой задачи нельзя пользоваться условной инструкцией if и циклами.

# n = int (input())
# m = int (input())

# print((m + n - 1)//n)

# В некоторой школе решили набрать три новых математических класса и оборудовать кабинеты для
# них новыми партами. За каждой партой может сидеть два учащихся. Известно количество учащихся в
# каждом из трех классов. Выведите наименьшее число парт, которое нужно приобрести для них.
# Input: 20 21 22(ввод чисел НЕ в одну строку) Output: 32

# a = int(input())
# b = int(input())
# c = int(input())

# s1 = ((a+1)//2)
# s2 = ((b+1)//2)
# s3 = ((c+1)//2)

# print(s1 + s2 + s3)

# Вагоны в электричке пронумерованы натуральными числами, начиная с 1 (при этом иногда вагоны
# нумеруются от «головы» поезда, а иногда – с  «хвоста»; это зависит от того, в какую сторону едет
# электричка). В каждом вагоне написан его номер. Витя сел в i-й вагон от головы поезда и обнаружил,
# что его вагон имеет номер j. Он хочет определить, сколько всего вагонов в электричке. Напишите
# программу, которая будет это делать или сообщать,что без дополнительной информации это сделать
# невозможно.Input: 3 4(ввод на разных строках) Output: 6

# i = int(input())
# j = int(input())

# if i - j == 0:
#     print(-1)
# else:
#     print(i + j -1)

# Дано натуральное число. Требуется определить,является ли год с данным номером високосным. Если
# год является високосным, то выведите YES, иначевыведите NO. Напомним, что в соответствии с
# григорианским календарем, год является високосным, если его номер кратен 4, но не кратен
# 100, а также если он кратен 400.Input: 2016 Output: YES

# n = int(input())

# if n % 4 == 0 and n % 100 != 0 or n % 400 == 0:
#     print("YES")
# else:
#     print("NO")

# Найдите сумму цифр трехзначного числа.

# n = int(input())
# if 100 <= n <= 999:
#   a = n // 100
#   b = (n % 100) // 10
#   c = n % 10
#   res = a + b + c
#   print(res)
# m = int(input())
# sum = 0
# for i in range(len(str(m))):
#     sum += m // 10 ** i % 10
# print(sum)


# S = 60

# # Вычисляем количество журавликов, сделанных Петей и Сережей
# x = S // 6

# # Количество журавликов, сделанных Катей
# y = 2 * (x + x)

# print(x, y, x)

# Вы пользуетесь общественным транспортом? Вероятно, вы
# расплачивались за проезд и получали билет с номером. Счастливым
# билетом называют такой билет с шестизначным номером, где сумма
# первых трех цифр равна сумме последних трех. Т.е. билет с номером
# 385916 – счастливый, т.к. 3+8+5=9+1+6. Вам требуется написать
# программу, которая проверяет счастливость билета.


# n = int(input())


# a1 = n // 100000
# a2 = (n % 100000) // 10000
# a3 = (n % 10000) // 1000
# a4 = (n % 1000) // 100
# a5 = (n % 100) // 10
# a6 = n % 10


# if a1 + a2 + a3 == a4 + a5 + a6:
#     print("yes")
# else:
#     print("no")

# Определите, можно ли от шоколадки размером a × b долек отломить c долек, если разрешается сделать один разлом по прямой между дольками (то есть разломить шоколадку на два прямоугольника).

# Выведите yes или no соответственно.

# a = 3
# b = 2
# c = 4

# if (a * b >= c) and ((c % a == 0) or (c % b == 0)):
#     print("yes")
# else:
#     print("no")

# На столе лежат n монеток. Некоторые из них лежат вверх
# решкой, а некоторые – гербом. Определите минимальное число
# монеток, которые нужно перевернуть, чтобы все монетки были
# повернуты вверх одной и той же стороной. Выведите минимальное
# количество монет, которые нужно перевернуть.


# coins = [0, 1, 0, 1, 1, 0]

# heads = 0  # количество монеток с гербом вверх
# tails = 0  # количество монеток с решкой вверх

# for coin in coins:
#     if coin == 0:
#         heads += 1
#     else:
#         tails += 1

# min_coins = min(heads, tails)  # минимальное количество монеток для переворота

# print(min_coins)

# Петя и Катя – брат и сестра. Петя – студент, а Катя – школьница. Петя помогает Кате по математике.
# Он задумывает два натуральных числа X и Y (X,Y≤1000), а Катя должна их отгадать. Для этого Петя делает две подсказки. Он называет сумму этих чисел S и их произведение P. Помогите Кате отгадать задуманные Петей числа.
# Примечание: числа S и P задавать не нужно, они будут передаваться в тестах. В результате вы должны вывести все возможные пары чисел X и Y через пробел, такие что X <= Y.

# s = 12
# p = 27

# for x in range(1, s + 1):
#     if p % x == 0:  # проверяем, делится ли p на x без остатка
#         y = p // x  # находим значение y, делением p на x
#         if x + y == s and x <= y:
         
#          print(x, y)

# Требуется вывести все целые степени двойки (т.е. числа вида 2k), не превосходящие числаN.

# n = 16
# power_2 = 1

# while power_2 <= n:
#     print(power_2)
#     power_2 *= 2

# # Дан список чисел. Определите, сколько в нем
# встречается различных чисел.
# Input: [1, 1, 2, 0, -1, 3, 4, 4]
# Output: 6

# list = [1, 1, 2, 0, -1, 3, 4, 4]
# print(set(list))    
# print(len(set(list)))

# Дана последовательность из N целых чисел и число
# K. Необходимо сдвинуть всю последовательность
# (сдвиг - циклический) на K элементов вправо, K –
# положительное число.
# Input: [1, 2, 3, 4, 5] k = 3
# Output: [4, 5, 1, 2, 3]

# list = [1, 2, 3, 4, 5]
# #k = int(input())
# k = 3
# k = k % len(list)

# list_res = []
# for i in range(k):
#     list_res.append(list[len(list) - 1 - i])
# print(list_res)    
# for i in range(len(list) - k):
#     list_res.append(list[i])
# print(list_res)    

# Напишите программу для печати всех уникальных
# значений в словаре.
# Input: [{"V": "S001"}, {"V": "S002"}, {"VI": "S001"},
# {"VI": "S005"}, {"VII": " S005 "}, {" V ":" S009 "}, {" VIII
# ":" S007 "}]
# Output: {'S005', 'S002', 'S007', 'S001', 'S009'}

# list_1 =  [{"V": "S001"}, {"V": "S002"}, {"VI": "S001"},{"VI": "S005"}, {"VII": " S005 "}, {" V ":" S009 "}, {" VIII ":" S007 "}]
# set_1 = set()

# for i in list_1:
#     for j in i:
#         set_1.add(i[j])
# print(set_1)         
    
# Дан массив, состоящий из целых чисел. Напишите
# программу, которая подсчитает количество
# элементов массива, больших предыдущего (элемента
# с предыдущим номером)
# Input: [0, -1, 5, 2, 3]
# Output: 2 (-1 < 5, 2 < 3)

# list_1 = [0, -1, 5, 2, 3] 
# count = 0

# for i in range(1, len(list_1)):
#     if list_1[i] > list_1[i-1]:
#         count +=1
# print(count)


# : Требуется вычислить, сколько раз встречается некоторое
# число X в массиве A[1..N]. Пользователь в первой строке вводит
# натуральное число N – количество элементов в массиве. В последующих
# строках записаны N целых чисел Ai
# . Последняя строка содержит число X

# list_1 = [1, 2, 3, 4, 5]
# k = 3
# count = 0
# for i in list_1:
#     if i == k:
#      count += 1
    
# print(count)

# Требуется найти в массиве A[1..N] самый близкий по
# величине элемент к заданному числу X. Пользователь в первой строке
# вводит натуральное число N – количество элементов в массиве. В
# последующих строках записаны N целых чисел Ai
# . Последняя строка
# содержит число X

# list_1 = [1, 2, 3, 4, 5]
# k = 6

# closest = list_1[0]  # предполагаем, что первый элемент ближайший
# min_difference = abs(k - closest)  # минимальная разница

# for num in list_1:
#     difference = abs(k - num)
#     if difference < min_difference:
#         min_difference = difference
#         closest = num

# print(closest)


#  В настольной игре Скрабл (Scrabble) каждая буква имеет определенную
# ценность. В случае с английским алфавитом очки распределяются так:
# ● A, E, I, O, U, L, N, S, T, R – 1 очко;
# ● D, G – 2 очка;
# ● B, C, M, P – 3 очка;
# ● F, H, V, W, Y – 4 очка;
# ● K – 5 очков;
# ● J, X – 8 очков;
# ● Q, Z – 10 очков.
# А русские буквы оцениваются так:
# ● А, В, Е, И, Н, О, Р, С, Т – 1 очко;
# ● Д, К, Л, М, П, У – 2 очка;
# ● Б, Г, Ё, Ь, Я – 3 очка;
# ● Й, Ы – 4 очка;
# ● Ж, З, Х, Ц, Ч – 5 очков;
# ● Ш, Э, Ю – 8 очков;
# ● Ф, Щ, Ъ – 10 очков.
# Напишите программу, которая вычисляет стоимость введенного пользователем слова.
# Будем считать, что на вход подается только одно слово, которое содержит либо только
# английские, либо только русские буквы.

# k = 'ноутбук'

# Словарь со значениями букв для английского алфавита
# english_scores = {
#     'A': 1, 'E': 1, 'I': 1, 'O': 1, 'U': 1, 'L': 1, 'N': 1, 'S': 1, 'T': 1, 'R': 1,
#     'D': 2, 'G': 2,
#     'B': 3, 'C': 3, 'M': 3, 'P': 3,
#     'F': 4, 'H': 4, 'V': 4, 'W': 4, 'Y': 4,
#     'K': 5,
#     'J': 8, 'X': 8,
#     'Q': 10, 'Z': 10
# }

# # Словарь со значениями букв для русского алфавита
# russian_scores = {
#     'А': 1, 'В': 1, 'Е': 1, 'И': 1, 'Н': 1, 'О': 1, 'Р': 1, 'С': 1, 'Т': 1,
#     'Д': 2, 'К': 2, 'Л': 2, 'М': 2, 'П': 2, 'У': 2,
#     'Б': 3, 'Г': 3, 'Ё': 3, 'Ь': 3, 'Я': 3,
#     'Й': 4, 'Ы': 4,
#     'Ж': 5, 'З': 5, 'Х': 5, 'Ц': 5, 'Ч': 5,
#     'Ш': 8, 'Э': 8, 'Ю': 8,
#     'Ф': 10, 'Щ': 10, 'Ъ': 10
# }

# # Ввод слова от пользователя
# k = 'ноутбук'

# # Определение языка введенного слова (английский или русский)
# language = 'english' if k[0].upper() in english_scores else 'russian'

# # Вычисление стоимости слова
# score = 0
# for letter in k.upper():
#     if language == 'english':
#         score += english_scores[letter]
#     else:
#         score += russian_scores[letter]

# # Вывод результата
# print(f"{score}")

# Даны два неупорядоченных набора целых чисел (может быть, с повторениями). Выдать без повторений в порядке возрастания все те числа, которые встречаются в обоих наборах.
# На вход подается 2 числа через пробел: n m
# n - кол-во элементов первого множества.
# m - кол-во элементов второго множества.
# Затем подаются элементы каждого множества через пробел в виде строки. ! Писать input() не надо

# Пример

# На входе:

# Заданные значения
# var1 = '5 4' 
# var2 = '1 3 5 7 9' 
# var3 = '2 3 4 5'

# # Разбиваем строку на отдельные элементы
# n, m = map(int, var1.split())
# set1 = set(map(int, var2.split()))
# set2 = set(map(int, var3.split()))

# # Находим пересечение множеств и сортируем его
# intersection = sorted(set1.intersection(set2))

# # Выводим результат
# print(*intersection)

#  Напишите  функции программу, которая на вход принимает
# два числа A и B, и возводит число А в целую степень B с
# помощью рекурсии.

# def f(a, b):
#     if b == 0:
#         return 1
#     elif b > 0:
#         return a * f(a, b - 1)
#     else:
#         return 1 / f(a, -b)

# a = 2
# b = 10
# print(f(a, b))











# В фермерском хозяйстве в Карелии выращивают чернику. Черника растет на круглой грядке, и кусты черники высажены по окружности грядки. Каждый куст черники имеет урожайность, которая соответствует количеству ягод на этом кусте.

# Урожайность черничных кустов представлена в виде списка arr, где arr[i] - это урожайность (количество ягод) i-го куста.

# В фермерском хозяйстве внедрена система автоматического сбора черники. Эта система состоит из управляющего модуля и нескольких собирающих модулей. Каждый собирающий модуль может собрать ягоды с одного куста и с двух соседних кустов. Собирающий модуль находится перед определенным кустом, и он может выбирать, с какого куста начать сбор ягод.

# Ваша задача - написать программу, которая определит максимальное число ягод, которое может собрать один собирающий модуль за один заход, находясь перед некоторым кустом грядки.

# Входные данные:

# На вход программе подается список arr, где arr[i] (1 ≤ arr[i] ≤ 1000) - урожайность i-го куста черники. Размер списка не превышает 1000 элементов.

# Выходные данные:

# Программа должна вывести одно целое число - максимальное количество ягод, которое может собрать собирающий модуль, находясь перед некоторым кустом грядки.

# arr = [5, 8, 6, 4, 9, 2, 7, 3]
# max_harvest = 0
# n = len(arr)

# for i in range(n):
#     current_harvest = arr[i]
    
#     if i > 0:
#         current_harvest += arr[i - 1]
#     if i < n - 1:
#         current_harvest += arr[i + 1]
    
#     max_harvest = max(max_harvest, current_harvest)

# print(max_harvest)

# Напишите рекурсивную функцию sum(a, b), возвращающую сумму двух целых неотрицательных чисел. Из всех арифметических операций допускаются только +1 и -1. Также нельзя использовать циклы.

# Функция не должна ничего выводить, только возвращать значение.

# def sum(a, b):
    
#     if a == 0:
#         return b
#     elif b == 0:
#         return a
    
#     else:
#         return sum(a - 1, b) + 1

# # Пример использования:
# result = sum(3, 5)
# print(result)  # Выведет: 8

# Определить индексы элементов массива (списка), значения которых принадлежат заданному диапазону 
# (т.е. не меньше заданного минимума и не больше заданного максимума).
# На вход подается список с элементамиlist_1 и границы диапазона в виде чисел min_number, max_number.

# def find_indices_in_range(list_1, min_number, max_number):
#     indices = []
#     for i, num in enumerate(list_1):
#         if min_number < num < max_number:
#             indices.append(i)
#     return indices

# list_1 = [-5, 9, 0, 3, -1, -2, 1, 4, -2, 10, 2, 0, -9, 8, 10, -9, 0, -5, -5, 7]
# min_number = 0
# max_number = 10

# result_indices = find_indices_in_range(list_1, min_number, max_number)
# print(*result_indices, sep='\n')

# Заполните массив элементами арифметической прогрессии. Её первый элемент a1 , 
# разность d и количество элементов n будет задано автоматически. 
# Формула для получения n-го члена прогрессии: an = a1 + (n-1) * d.

# def arithmetic_progression(a1, d, n):
#     progression = []
#     for i in range(n):
#         progression.append(a1 + i * d)
#     return progression

# a1 = 2
# d = 3
# n = 4

# progression = arithmetic_progression(a1, d, n)
# for num in progression:
#     print(num)


# У вас есть код, который вы не можете менять(так часто бывает, когда код в глубине
# программы используется множество раз и вы не хотите ничего сломать):
# transformation = <???>
# values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # или любой другой список
# transormed_values = list(map(transformation, values))
# Единственный способ вашего взаимодействия с этим кодом - посредством задания
# функции transformation.
# Однако вы поняли, что для вашей текущей задачи вам не нужно никак преобразовывать
# список значений, а нужно получить его как есть.
# Напишите такое лямбда-выражение transformation, чтобы transformed_values получился
# копией values.

# transformation = lambda x: x
# values = [2, 3, 5, 7, 13]
# transformed_values = list(map(transformation, values))
# if values == transformed_values:
#     print('ok')
# else:
#     print('fail')

# Планеты вращаются вокруг звезд по эллиптическим орбитам.
# Назовем самой далекой планетой ту, орбита которой имеет
# самую большую площадь. Напишите функцию
# find_farthest_orbit(list_of_orbits), которая среди списка орбит
# планет найдет ту, по которой вращается самая далекая
# планета. Круговые орбиты не учитывайте: вы знаете, что у
# вашей звезды таких планет нет, зато искусственные спутники
# были были запущены на круговые орбиты. Результатом
# # функции должен быть кортеж, содержащий длины полуосей
# # эллипса орбиты самой далекой планеты. Каждая орбита
# # представляет из себя кортеж из пары чисел - полуосей ее
# # эллипса. Площадь эллипса вычисляется по формуле S = pi*a*b,
# # где a и b - длины полуосей эллипса. При решении задачи
# # используйте списочные выражения. Подсказка: проще всего
# # будет найти эллипс в два шага: сначала вычислить самую
# # большую площадь эллипса, а затем найти и сам эллипс,
# # имеющий такую площадь. Гарантируется, что самая далекая
# # планета ровно одна

# # from math import pi   #можем импортировать число пи таким образом s = pi*a*b

# # def find_farthest_orbit(list_of_orbits):
# #     list_1 = [i for i in list_of_orbits if i[0] != i[1]]
# #     list_s = [(pi * i[0] * i[1]) for i in list_1]
# #     max_s = list_s.index(max(list_s))     # index() найдет значение каждый индекс номера
    
# #     return list_1[max_s]
    

# # orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
# # print(*find_farthest_orbit(orbits))

# # Напишите функцию same_by(characteristic, objects), которая
# # проверяет, все ли объекты имеют одинаковое значение
# # некоторой характеристики, и возвращают True, если это так.
# # Если значение характеристики для разных объектов
# # отличается - то False. Для пустого набора объектов, функция
# # должна возвращать True. Аргумент characteristic - это
# # функция, которая принимает объект и вычисляет его
# # характеристику.

# # def same_by(characteristic, objects): 
# #     result = True
# #     list1 = [characteristic(x) for x in objects]
# #     for i in range(len(list1) - 1):
# #         if list1[i] != list1[i+1]:
# #             result = False
# #     return result    
    
    
# # values = [0, 2, 10, 6]        
# # if same_by(lambda x: x % 2, values):
# #     print('same')
# # else:
# #    print('different')

# # Напишите функцию print_operation_table(operation, num_rows=9, num_columns=9),
# # которая принимает в качестве аргумента функцию, вычисляющую элемент по номеру строки и
# # столбца. Аргументы num_rows и num_columns указывают число строк и столбцов таблицы,
# # которые должны быть распечатаны. Нумерация строк и столбцов идет с единицы (подумайте,
# # почему не с нуля). Примечание: бинарной операцией называется любая операция, у которой
# # ровно два аргумента, как, например, у операции умножения.
    
# def print_operation_table(operation, num_rows=9, num_columns=9):
#     # Проверяем, что размерности таблицы больше 2
#     if num_rows < 2 or num_columns < 2:
#         print("ОШИБКА! Размерности таблицы должны быть больше 2!")
#         return

#     # Печатаем таблицу
#     for i in range(1, num_rows + 1):
#         row = []
#         for j in range(1, num_columns + 1):
#             row.append(str(operation(i, j)))
#         print(" ".join(row))

# # Пример использования
# print_operation_table(lambda x, y: x * y, 3, 3)


# # Винни-Пух попросил Вас посмотреть, есть ли в его стихах ритм. Поскольку
# # разобраться в его кричалках не настолько просто, насколько легко он их придумывает, Вам
# # стоит написать программу. Винни-Пух считает, что ритм есть, если число слогов (т.е. число
# # гласных букв) в каждой фразе стихотворения одинаковое. Фраза может состоять из одного
# # слова, если во фразе несколько слов, то они разделяются дефисами. Фразы отделяются друг
# # от друга пробелами. Стихотворение Винни-Пух вбивает в программу с клавиатуры. В ответе
# # напишите “Парам пам-пам”, если с ритмом все в порядке и “Пам парам”, если с ритмом все не
# # в порядке
# # Ввод: Вывод:
# # пара-ра-рам рам-пам-папам па-ра-па-дам Парам пам-пам

# def check_rhythm(stroka):
#     # Определяем функцию для подсчета гласных букв в слове
#     def count_vowels(word):
#         vowels = 'аеёиоуыэюя'
#         return sum(1 for char in word if char in vowels)
    
#     # Разделяем строку на фразы
#     phrases = stroka.split()
    
#     # Проверяем количество фраз
#     if len(phrases) < 2:
#         return "Количество фраз должно быть больше одной!"
    
#     # Подсчитываем количество гласных в каждой фразе
#     syllables_count = [sum(count_vowels(word) for word in phrase.split('-')) for phrase in phrases]
    
#     # Проверяем, одинаковое ли количество гласных в каждой фразе
#     if all(count == syllables_count[0] for count in syllables_count):
#         return "Парам пам-пам"
#     else:
#         return "Пам парам"

# # Пример использования
# stroka = 'пара-ра-рам рам-пам-папам па-ра-па-дам'
# print(check_rhythm(stroka))

# другой вариант более простой ответ
# vowels = ['а', 'е', 'ё', 'и', 'й', 'о', 'у', 'ы', 'э', 'ю', 'я']
# phrases = stroka.split()
# if len(phrases) < 2:
#  print('Количество фраз должно быть больше одной!')
# else:
#  countVowels = []

#  for i in phrases:
#   countVowels.append(len([x for x in i if x.lower() in vowels]))

#  if countVowels.count(countVowels[0]) == len(countVowels):
#   print('Парам пам-пам')
#  else:
#   print('Пам парам')


    









